// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @title RedEnvelope - 智能合约红包系统\n * @dev 开发版本，使用简化的随机数生成\n */\ncontract RedEnvelope {\n    struct Envelope {\n        uint256 id;\n        address creator;\n        uint256 totalAmount;\n        uint256 remainingAmount;\n        uint256 totalPackets;\n        uint256 remainingPackets;\n        uint256[] amounts;\n        address[] claimedBy;\n        bool isActive;\n        uint256 createdAt;\n    }\n    \n    mapping(uint256 => Envelope) public envelopes;\n    mapping(uint256 => mapping(address => bool)) public hasClaimed;\n    \n    uint256 public nextEnvelopeId;\n    uint256 public constant MAX_PACKETS = 6;\n    uint256 private nonce;\n    \n    event EnvelopeCreated(uint256 indexed envelopeId, address indexed creator, uint256 totalAmount, uint256 packets);\n    event EnvelopeClaimed(uint256 indexed envelopeId, address indexed claimer, uint256 amount);\n    \n    modifier envelopeExists(uint256 _envelopeId) {\n        require(_envelopeId < nextEnvelopeId, \"Envelope does not exist\");\n        _;\n    }\n    \n    modifier envelopeActive(uint256 _envelopeId) {\n        require(envelopes[_envelopeId].isActive, \"Envelope is not active\");\n        require(envelopes[_envelopeId].remainingPackets > 0, \"No packets remaining\");\n        _;\n    }\n    \n    /**\n     * @dev 创建红包\n     */\n    function createEnvelope() external payable {\n        require(msg.value > 0, \"Must send ETH to create envelope\");\n        \n        uint256 envelopeId = nextEnvelopeId++;\n        \n        // 生成随机金额分配\n        uint256[] memory amounts = _generateRandomAmounts(msg.value, MAX_PACKETS);\n        \n        envelopes[envelopeId] = Envelope({\n            id: envelopeId,\n            creator: msg.sender,\n            totalAmount: msg.value,\n            remainingAmount: msg.value,\n            totalPackets: MAX_PACKETS,\n            remainingPackets: MAX_PACKETS,\n            amounts: amounts,\n            claimedBy: new address[](0),\n            isActive: true,\n            createdAt: block.timestamp\n        });\n        \n        emit EnvelopeCreated(envelopeId, msg.sender, msg.value, MAX_PACKETS);\n    }\n    \n    /**\n     * @dev 抢红包\n     */\n    function claimEnvelope(uint256 _envelopeId) \n        external \n        envelopeExists(_envelopeId) \n        envelopeActive(_envelopeId) \n    {\n        require(!hasClaimed[_envelopeId][msg.sender], \"Already claimed this envelope\");\n        require(msg.sender != envelopes[_envelopeId].creator, \"Creator cannot claim own envelope\");\n        \n        Envelope storage envelope = envelopes[_envelopeId];\n        \n        // 获取随机可用的红包\n        uint256 packetIndex = _getRandomAvailablePacket(_envelopeId);\n        uint256 claimAmount = envelope.amounts[packetIndex];\n        \n        // 标记为已领取\n        hasClaimed[_envelopeId][msg.sender] = true;\n        envelope.claimedBy.push(msg.sender);\n        envelope.remainingAmount -= claimAmount;\n        envelope.remainingPackets--;\n        \n        // 从可用金额中移除已领取的金额\n        for (uint256 i = packetIndex; i < envelope.amounts.length - 1; i++) {\n            envelope.amounts[i] = envelope.amounts[i + 1];\n        }\n        envelope.amounts.pop();\n        \n        // 如果所有红包都被领取，则停用\n        if (envelope.remainingPackets == 0) {\n            envelope.isActive = false;\n        }\n        \n        // 转账ETH给领取者\n        (bool success, ) = payable(msg.sender).call{value: claimAmount}(\"\");\n        require(success, \"Transfer failed\");\n        \n        emit EnvelopeClaimed(_envelopeId, msg.sender, claimAmount);\n    }\n    \n    /**\n     * @dev 获取红包信息\n     */\n    function getEnvelope(uint256 _envelopeId) \n        external \n        view \n        envelopeExists(_envelopeId) \n        returns (\n            uint256 id,\n            address creator,\n            uint256 totalAmount,\n            uint256 remainingAmount,\n            uint256 totalPackets,\n            uint256 remainingPackets,\n            address[] memory claimedBy,\n            bool isActive,\n            uint256 createdAt\n        ) \n    {\n        Envelope memory envelope = envelopes[_envelopeId];\n        return (\n            envelope.id,\n            envelope.creator,\n            envelope.totalAmount,\n            envelope.remainingAmount,\n            envelope.totalPackets,\n            envelope.remainingPackets,\n            envelope.claimedBy,\n            envelope.isActive,\n            envelope.createdAt\n        );\n    }\n    \n    /**\n     * @dev 检查用户是否已领取红包\n     */\n    function hasUserClaimed(uint256 _envelopeId, address _user) \n        external \n        view \n        returns (bool) \n    {\n        return hasClaimed[_envelopeId][_user];\n    }\n    \n    /**\n     * @dev 获取红包总数\n     */\n    function getTotalEnvelopes() external view returns (uint256) {\n        return nextEnvelopeId;\n    }\n    \n    /**\n     * @dev 生成随机金额分配（内部函数）\n     */\n    function _generateRandomAmounts(uint256 totalAmount, uint256 packets) \n        private \n        returns (uint256[] memory) \n    {\n        uint256[] memory amounts = new uint256[](packets);\n        uint256 remaining = totalAmount;\n        \n        // 为前5个红包分配随机金额\n        for (uint256 i = 0; i < packets - 1; i++) {\n            uint256 maxAmount = remaining / (packets - i); // 平均剩余金额\n            uint256 minAmount = remaining / (packets * 10); // 最小金额（总额的1/60）\n            \n            if (remaining <= minAmount * (packets - i)) {\n                amounts[i] = minAmount;\n            } else {\n                uint256 randomValue = _generateRandomNumber(i + totalAmount);\n                uint256 range = (maxAmount > minAmount) ? maxAmount - minAmount : 0;\n                amounts[i] = minAmount + (range > 0 ? randomValue % range : 0);\n                \n                // 确保不会超过剩余金额\n                if (amounts[i] > remaining - minAmount * (packets - i - 1)) {\n                    amounts[i] = remaining - minAmount * (packets - i - 1);\n                }\n            }\n            \n            remaining -= amounts[i];\n        }\n        \n        // 最后一个红包获得剩余金额\n        amounts[packets - 1] = remaining;\n        \n        return amounts;\n    }\n    \n    /**\n     * @dev 获取随机可用红包索引（内部函数）\n     */\n    function _getRandomAvailablePacket(uint256 _envelopeId) \n        private \n        returns (uint256) \n    {\n        Envelope storage envelope = envelopes[_envelopeId];\n        uint256 randomValue = _generateRandomNumber(_envelopeId + block.timestamp);\n        return randomValue % envelope.amounts.length;\n    }\n    \n    /**\n     * @dev 生成伪随机数（仅用于演示，不具备加密安全性）\n     */\n    function _generateRandomNumber(uint256 seed) private returns (uint256) {\n        nonce++;\n        return uint256(keccak256(abi.encodePacked(\n            block.timestamp,\n            block.number,\n            msg.sender,\n            nonce,\n            seed\n        )));\n    }\n}