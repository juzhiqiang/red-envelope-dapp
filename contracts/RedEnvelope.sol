// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ncontract RedEnvelope {\n    struct Envelope {\n        uint256 id;\n        address creator;\n        uint256 totalAmount;\n        uint256 remainingAmount;\n        uint256 totalPackets;\n        uint256 remainingPackets;\n        uint256[] amounts;\n        address[] claimedBy;\n        bool isActive;\n        uint256 createdAt;\n    }\n    \n    mapping(uint256 => Envelope) public envelopes;\n    mapping(uint256 => mapping(address => bool)) public hasClaimed;\n    \n    uint256 public nextEnvelopeId;\n    uint256 public constant MAX_PACKETS = 6;\n    uint256 private nonce;\n    \n    event EnvelopeCreated(uint256 indexed envelopeId, address indexed creator, uint256 totalAmount, uint256 packets);\n    event EnvelopeClaimed(uint256 indexed envelopeId, address indexed claimer, uint256 amount);\n    \n    modifier envelopeExists(uint256 _envelopeId) {\n        require(_envelopeId < nextEnvelopeId, \"Envelope does not exist\");\n        _;\n    }\n    \n    modifier envelopeActive(uint256 _envelopeId) {\n        require(envelopes[_envelopeId].isActive, \"Envelope is not active\");\n        require(envelopes[_envelopeId].remainingPackets > 0, \"No packets remaining\");\n        _;\n    }\n    \n    function createEnvelope() external payable {\n        require(msg.value > 0, \"Must send ETH to create envelope\");\n        \n        uint256 envelopeId = nextEnvelopeId++;\n        \n        // Generate random amounts for 6 packets\n        uint256[] memory amounts = _generateRandomAmounts(msg.value, MAX_PACKETS);\n        \n        envelopes[envelopeId] = Envelope({\n            id: envelopeId,\n            creator: msg.sender,\n            totalAmount: msg.value,\n            remainingAmount: msg.value,\n            totalPackets: MAX_PACKETS,\n            remainingPackets: MAX_PACKETS,\n            amounts: amounts,\n            claimedBy: new address[](0),\n            isActive: true,\n            createdAt: block.timestamp\n        });\n        \n        emit EnvelopeCreated(envelopeId, msg.sender, msg.value, MAX_PACKETS);\n    }\n    \n    function claimEnvelope(uint256 _envelopeId) \n        external \n        envelopeExists(_envelopeId) \n        envelopeActive(_envelopeId) \n    {\n        require(!hasClaimed[_envelopeId][msg.sender], \"Already claimed this envelope\");\n        require(msg.sender != envelopes[_envelopeId].creator, \"Creator cannot claim own envelope\");\n        \n        Envelope storage envelope = envelopes[_envelopeId];\n        \n        // Get random available packet\n        uint256 packetIndex = _getRandomAvailablePacket(_envelopeId);\n        uint256 claimAmount = envelope.amounts[packetIndex];\n        \n        // Mark as claimed\n        hasClaimed[_envelopeId][msg.sender] = true;\n        envelope.claimedBy.push(msg.sender);\n        envelope.remainingAmount -= claimAmount;\n        envelope.remainingPackets--;\n        \n        // Remove the claimed amount from available amounts\n        for (uint256 i = packetIndex; i < envelope.amounts.length - 1; i++) {\n            envelope.amounts[i] = envelope.amounts[i + 1];\n        }\n        envelope.amounts.pop();\n        \n        // Deactivate if all packets claimed\n        if (envelope.remainingPackets == 0) {\n            envelope.isActive = false;\n        }\n        \n        // Transfer ETH to claimer\n        (bool success, ) = payable(msg.sender).call{value: claimAmount}(\"\");\n        require(success, \"Transfer failed\");\n        \n        emit EnvelopeClaimed(_envelopeId, msg.sender, claimAmount);\n    }\n    \n    function getEnvelope(uint256 _envelopeId) \n        external \n        view \n        envelopeExists(_envelopeId) \n        returns (\n            uint256 id,\n            address creator,\n            uint256 totalAmount,\n            uint256 remainingAmount,\n            uint256 totalPackets,\n            uint256 remainingPackets,\n            address[] memory claimedBy,\n            bool isActive,\n            uint256 createdAt\n        ) \n    {\n        Envelope memory envelope = envelopes[_envelopeId];\n        return (\n            envelope.id,\n            envelope.creator,\n            envelope.totalAmount,\n            envelope.remainingAmount,\n            envelope.totalPackets,\n            envelope.remainingPackets,\n            envelope.claimedBy,\n            envelope.isActive,\n            envelope.createdAt\n        );\n    }\n    \n    function hasUserClaimed(uint256 _envelopeId, address _user) \n        external \n        view \n        returns (bool) \n    {\n        return hasClaimed[_envelopeId][_user];\n    }\n    \n    function getTotalEnvelopes() external view returns (uint256) {\n        return nextEnvelopeId;\n    }\n    \n    // Internal function to generate random amounts\n    function _generateRandomAmounts(uint256 totalAmount, uint256 packets) \n        private \n        returns (uint256[] memory) \n    {\n        uint256[] memory amounts = new uint256[](packets);\n        uint256 remaining = totalAmount;\n        \n        for (uint256 i = 0; i < packets - 1; i++) {\n            // Generate random amount between 1% and remaining amount minus minimum for others\n            uint256 maxAmount = remaining - (packets - i - 1) * (totalAmount / 100); // Leave at least 1% for each remaining packet\n            uint256 minAmount = totalAmount / 100; // Minimum 1% of total\n            \n            if (maxAmount <= minAmount) {\n                amounts[i] = minAmount;\n            } else {\n                uint256 randomValue = _generateRandomNumber(i);\n                amounts[i] = minAmount + (randomValue % (maxAmount - minAmount));\n            }\n            remaining -= amounts[i];\n        }\n        \n        // Last packet gets remaining amount\n        amounts[packets - 1] = remaining;\n        \n        return amounts;\n    }\n    \n    // Internal function to get random available packet\n    function _getRandomAvailablePacket(uint256 _envelopeId) \n        private \n        returns (uint256) \n    {\n        Envelope storage envelope = envelopes[_envelopeId];\n        uint256 randomValue = _generateRandomNumber(_envelopeId);\n        uint256 randomIndex = randomValue % envelope.amounts.length;\n        return randomIndex;\n    }\n    \n    // Generate pseudo-random number (not cryptographically secure, for demo purposes only)\n    function _generateRandomNumber(uint256 seed) private returns (uint256) {\n        nonce++;\n        return uint256(keccak256(abi.encodePacked(\n            block.timestamp,\n            block.prevrandao, // Use prevrandao instead of deprecated difficulty\n            msg.sender,\n            nonce,\n            seed\n        )));\n    }\n}